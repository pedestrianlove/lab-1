<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>eBPF實作 - Lab 1</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">eBPF實作 - Lab 1</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ebpf-介紹"><a class="header" href="#ebpf-介紹">eBPF 介紹</a></h1>
<p>屬於核心（kernel）程式開發。與核心模組主要差別在<strong>驗證器</strong>（verifier）和 <strong>map</strong> 的設計。驗證器由 Linux kernel 提供，確認被加載的程式的正確性。map 則提供便利的通訊介面，讓 BPF 核心程式間和用戶程式能夠輕易的協作。</p>
<h2 id="追蹤程式介紹"><a class="header" href="#追蹤程式介紹">追蹤程式介紹</a></h2>
<p>eBPF 程式的兩個目的：觀測和改變核心行為，用於觀測的程式可以歸類為追蹤（trace）的類別。</p>
<p>追蹤程式底下可以再分成 kprobe/kretprobe, fentry/fexit 和 tracepoint ：</p>
<ul>
<li>kprobe/kretprobe, fentry/fexit: 主要觀察核心中的函式的進入和退出，可以取得呼叫函式的引數（arguments）和回傳值。被追蹤的程式無須修改和重新編譯，屬於動態追蹤的技術。</li>
<li>tracepoint: 核心程式碼設立和提供 tracepoint 以供觀測，屬於靜態追蹤。這套機制由 Linux 提供，屬於穩定的公開介面。</li>
</ul>
<h2 id="系統架構"><a class="header" href="#系統架構">系統架構</a></h2>
<p>系統元件圖:<br />
<img src="https://hackmd.io/_uploads/ByPo075gJe.png" alt="System Block Diagram" /></p>
<ul>
<li><code>hellp.py</code>、<code>hello()</code>：eBPF 程式，有核心和用戶兩個部分。課程中兩個部分都用 C 開發</li>
<li><code>trace pseudofile</code>：eBPF 程式核心和用戶溝通的機制，透過特殊檔案或 map</li>
<li><code>execve</code>、<code>小蜜蜂</code>：核心中的 tracepoint ，觸發附著的 eBPF 核心程式</li>
<li><code>Apps</code>：系統上所有應用程式，可能在系統呼叫時進入 tracepoint</li>
</ul>
<h2 id="開發工具和設定"><a class="header" href="#開發工具和設定">開發工具和設定</a></h2>
<ul>
<li>此篇省略系統設定，例如 Linux Kconfig 的設定</li>
<li>開發工具包含函式庫 libbpf （以及相依的 zlib、libelf）和命令列工具 bpftool。</li>
</ul>
<h2 id="檔案介紹"><a class="header" href="#檔案介紹">檔案介紹</a></h2>
<ul>
<li><code>&lt;app&gt;.bpf.c</code> ：核心程式，會轉成 <code>&lt;app&gt;.skel.h</code> skeleton 檔供用戶態程式使用</li>
<li><code>&lt;app&gt;.c</code> ：用戶程式，加載和附著核心程式</li>
<li><code>&lt;app&gt;.h</code> ：定義核心和用戶溝通時共用的類別</li>
<li><code>vmlinux.h</code> ：具有 kernel 內所有類別的定義</li>
<li><code>bpftool</code> ：生成 skeleton 和 <code>vmlinux.h</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="範例-minimal程式及其makefile"><a class="header" href="#範例-minimal程式及其makefile">範例: minimal程式及其Makefile</a></h1>
<p>核心監測到用戶使用系統呼叫 <code>write()</code> 時輸出訊息，用戶附著完核心程式後會不斷使用 <code>write()</code></p>
<h2 id="minimal-核心程式"><a class="header" href="#minimal-核心程式">minimal 核心程式</a></h2>
<pre><code class="language-c">// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
/* Copyright (c) 2020 Facebook */

// 這裡不符常規，用 "linux/bpf.h" 取代 "vmlinux.h"
// 需要定義在 bpf header 前面，因為 header 需要 kernel 類別
#include &lt;linux/bpf.h&gt;
#include &lt;bpf/bpf_helpers.h&gt;

// 部分 bpf api 需要 license
// SEC("license") 指定 symbol's section 
char LICENSE[] SEC("license") = "Dual BSD/GPL";

// supported since Linux 5.5
int my_pid = 0;

// define program type and attachment point
SEC("tp/syscalls/sys_enter_write")
int handle_tp(void *ctx)
{
    // return u64. [63: 32] is tgid, [31: 0] is pid
    // tgid is pid and pid is tid in kernel terminology
    int pid = bpf_get_current_pid_tgid() &gt;&gt; 32;

    if (pid != my_pid)
        return 0;

    // number of arguments is limited
    bpf_printk("BPF triggered from PID %d.\n", pid);

    return 0;
}
</code></pre>
<p>依據程式類型，函式有對應的簽名。 <code>handle_tp</code> 屬於 tracepoint ，參數只有一個指標，類別則是 tracepoint 名稱加上前綴 <code>trace_event_raw_</code> ，定義在 <code>vmlinux.h</code></p>
<h2 id="minimal-用戶程式"><a class="header" href="#minimal-用戶程式">minimal 用戶程式</a></h2>
<h3 id="minimalskelh"><a class="header" href="#minimalskelh">minimal.skel.h</a></h3>
<pre><code class="language-c">...
    
// kernel 程式對應的結構體
// 在呼叫 api 會使用 maps/progs/links
// bss/data/rodata 用戶可以直接存取
struct minimal_bpf {
	struct bpf_object_skeleton *skeleton;
	struct bpf_object *obj;
	struct {
		struct bpf_map *bss;
	} maps;
	struct {
		struct bpf_program *handle_tp;
	} progs;
	struct {
		struct bpf_link *handle_tp;
	} links;
	struct minimal_bpf__bss {
		int my_pid;
	} *bss;
};
</code></pre>
<p>skeleton 提供用戶的 api ，簡單的 eBPF 用戶程式可以不用自己呼叫 libbpf ，只需要使用 skeleton api</p>
<pre><code class="language-c">// setup
static inline struct minimal_bpf *minimal_bpf__open(void) { ... }
static inline int minimal_bpf__load(struct minimal_bpf *obj) { ... }
static inline struct minimal_bpf *minimal_bpf__open_and_load(void) { ... }
static inline int minimal_bpf__attach(struct minimal_bpf *obj) { ... }

// teardown
static inline void minimal_bpf__destroy(struct minimal_bpf *obj) { ... }
static inline void minimal_bpf__detach(struct minimal_bpf *obj) { ... }
</code></pre>
<h3 id="minimalc"><a class="header" href="#minimalc">minimal.c</a></h3>
<pre><code class="language-c">int main(int argc, char **argv)
{
    struct minimal_bpf *skel = minimal_bpf__open();
    skel-&gt;bss-&gt;my_pid = getpid();   // set global variable
    err = minimal_bpf__load(skel);  // Load &amp; verify BPF programs
    err = minimal_bpf__attach(skel);

    for (;;) {
        fprintf(stderr, ".");
        sleep(1);
    }

    minimal_bpf__destroy(skel);
    ...
}
</code></pre>
<ul>
<li>全域變數必須在程式加載前設定</li>
<li>tracepoints, kprobes 和特定類型的 eBPF 程式 libbpf 可以查看 <code>SEC()</code> 進行自動附著</li>
</ul>
<h2 id="ebpf-編譯流程"><a class="header" href="#ebpf-編譯流程">eBPF 編譯流程</a></h2>
<p><img src="https://hackmd.io/_uploads/SkVxXBs-yg.png" alt="截圖 2024-11-08 下午3.50.40" /></p>
<h2 id="makefile"><a class="header" href="#makefile">makefile</a></h2>
<h3 id="基本規則"><a class="header" href="#基本規則">基本規則</a></h3>
<p>makefile 是自動化建置工具，透過撰寫文字檔定義檔案的相依和生成規則，將程式碼編譯成執行檔。</p>
<pre><code class="language-makefile"># 檔名為 makefile 或 Makefile

目標文件 ...：依賴項目 ...  # 多個項目透過空格分開
    終端命令  # 開頭一定要是 TAB
    ...
</code></pre>
<p>在 makefile 檔案所在的目錄執行 <code>make &lt;目標文件&gt;</code> 生成特定目標， <code>make</code> 則是生成第一個規則的目標。</p>
<p>特殊符號說明：</p>
<ul>
<li><code>$^</code>： 所有依賴項目</li>
<li><code>$&lt;</code>： 第一個依賴項目</li>
<li><code>$@</code>： 目標文件</li>
</ul>
<h3 id="示範-makefile"><a class="header" href="#示範-makefile">示範 makefile</a></h3>
<pre><code class="language-makefile"># generate vmlinux header
vmlinux.h:
	bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; vmlinux.h 

# build bpf kernel object file
minimal.bpf.o: minimal.bpf.c vmlinux.h
	clang -g -O2 -target bpf -c $&lt; -o $@

# generate skeleton
minimal.skel.h: minimal.bpf.o
	bpftool gen skeleton $&lt; &gt; $@

# build app
minimal: minimal.c minimal.skel.h
	clang -g minimal.c -lbpf -lelf -lz -o $@

</code></pre>
<ul>
<li><code>-O2</code>, <code>-target bpf</code> 是必要的選項</li>
<li><code>-lbpf -lelf -lz</code> 執行檔動態連結函式庫</li>
<li>執行檔不用連結核心目標檔</li>
</ul>
<h2 id="除錯相關"><a class="header" href="#除錯相關">除錯相關</a></h2>
<ul>
<li>需要提升權限執行程式，也就是使用 <code>sudo ./&lt;executable&gt;</code> 執行</li>
<li>查看 eBPF 輸出訊息</li>
</ul>
<pre><code class="language-shell">$ sudo cat /sys/kernel/debug/tracing/trace_pipe
    &lt;...&gt;-3840345 [010] d... 3220701.101143: bpf_trace_printk: BPF triggered from PID 3840345.
    &lt;...&gt;-3840345 [010] d... 3220702.101265: bpf_trace_printk: BPF triggered from PID 3840345.
</code></pre>
<ul>
<li>查看當前附著的程式</li>
</ul>
<pre><code class="language-shell">$ sudo bpftool perf show
pid 232272  fd 17: prog_id 394  kprobe  func do_execve  offset 0
pid 232272  fd 19: prog_id 396  tracepoint  sys_enter_execve
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="實作-編譯minimal"><a class="header" href="#實作-編譯minimal">實作: 編譯minimal</a></h1>
<ol>
<li>
<p>設定好你的<a href="https://github.com/easy-ebpf/practice_vm">環境</a>。</p>
</li>
<li>
<p>下載範例，如果VM的桌面已經有了，也請<code>git pull</code>更新一下:</p>
</li>
</ol>
<pre><code class="language-shell">git clone https://github.com/easy-ebpf/lab-1.git
</code></pre>
<ol start="3">
<li>
<p>進入<code>src/minimal</code>目錄，並使用裡面寫好的makefile編譯<code>minimal</code>這個eBPF程式。</p>
</li>
<li>
<p>觀察 minimal 程式的輸出，並依提示使用其它指令確認程式正常運作。</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="map介紹-以bootstrap為例"><a class="header" href="#map介紹-以bootstrap為例">map介紹: 以bootstrap為例</a></h1>
<ul>
<li>程式執行的時候，在 hash map 紀錄 pid 和時間</li>
<li>程式結束的時候，利用 pid 查詢執行開始的時間，計算時長。將資訊透過 ring buffer 傳遞給用戶</li>
</ul>
<h2 id="hash-map"><a class="header" href="#hash-map">hash map</a></h2>
<p>eBPF map 的定義程式碼如下，根據種類稍有差異， hash map 包含 <code>type</code>、<code>key</code>、<code>value</code></p>
<pre><code class="language-c">struct {
	__uint(type, BPF_MAP_TYPE_HASH);
	__uint(max_entries, 8192);
	__type(key, pid_t);
	__type(value, u64);
} exec_start SEC(".maps");
</code></pre>
<details>
<summary>點我展開核心態的 map 操作 api</summary>
<pre><code class="language-c">/*
 * bpf_map_lookup_elem
 *
 * 	Perform a lookup in *map* for an entry associated to *key*.
 *
 * Returns
 * 	Map value associated to *key*, or **NULL** if no entry was
 * 	found.
 */
static void *(* const bpf_map_lookup_elem)(void *map, const void *key) = (void *) 1;

/*
 * bpf_map_update_elem
 *
 * 	Add or update the value of the entry associated to *key* in
 * 	*map* with *value*. *flags* is one of:
 *
 * 	**BPF_NOEXIST**
 * 		The entry for *key* must not exist in the map.
 * 	**BPF_EXIST**
 * 		The entry for *key* must already exist in the map.
 * 	**BPF_ANY**
 * 		No condition on the existence of the entry for *key*.
 *
 * 	Flag value **BPF_NOEXIST** cannot be used for maps of types
 * 	**BPF_MAP_TYPE_ARRAY** or **BPF_MAP_TYPE_PERCPU_ARRAY**  (all
 * 	elements always exist), the helper would return an error.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (* const bpf_map_update_elem)(void *map, const void *key, const void *value, __u64 flags) = (void *) 2;

/*
 * bpf_map_delete_elem
 *
 * 	Delete entry with *key* from *map*.
 *
 * Returns
 * 	0 on success, or a negative error in case of failure.
 */
static long (* const bpf_map_delete_elem)(void *map, const void *key) = (void *) 3;
</code></pre>
</details>
<div class="warning">
<p>核心及用戶 api 格式可能很像，但兩者是不同概念，一個使用系統呼叫，一個使用核心內的函式。</p>
</div>
<h2 id="ring-buffer"><a class="header" href="#ring-buffer">ring buffer</a></h2>
<p>從核心傳遞資料到用戶程式，api 操作流程大致為：</p>
<pre><code class="language-c">// 分配記憶體
struct event *e = bpf_ringbuf_reserve(&amp;rb, sizeof(*e), 0);

// 設定 e 的數值...

// 發送資料
bpf_ringbuf_submit(e, 0);
</code></pre>
<p>用戶接收部分則是：</p>
<pre><code class="language-c">// * 獲取資源，用 skeleton maps 下的成員指定 map
// 在程式加載之後才能操作 map
// * callback "handle_event" 來處理資料
rb = ring_buffer__new(bpf_map__fd(skel-&gt;maps.rb), handle_event, NULL, NULL);
...

// 處理資料的迴圈
while (!exiting) {
    err = ring_buffer__poll(rb, 100 /* timeout, ms */);
}
...

// 釋放資源
ring_buffer__free(rb);
</code></pre>
<h2 id="boostrap-核心程式"><a class="header" href="#boostrap-核心程式">boostrap 核心程式</a></h2>
<ul>
<li>
<p>讀取系統核心的資料或記憶體，需要特別的函式。例如從系統取得目前行程的 <code>struct task_struct</code> 讀取 ppid (parent pid)</p>
<pre><code class="language-c">struct task_struct *task = (struct task_struct *)bpf_get_current_task();
pid_t ppid = BPF_CORE_READ(task, real_parent, tgid);
</code></pre>
<p>功能在普通 c 語言等同於</p>
<pre><code class="language-c">pid_t ppid = task-&gt;real_parent-&gt;tgid;
</code></pre>
<p>已經宣告變數時，要傳入指標和大小，同系列的 api 有：</p>
<pre><code class="language-c">BPF_CORE_READ_INTO(&amp;ppid, task, real_parent, tgid);
bpf_core_read(&amp;ppid, sizeof(ppid), real_parent);
</code></pre>
</li>
<li>
<p>從參數中讀取資料</p>
<pre><code class="language-c">SEC("tp/sched/sched_process_exec")
int handle_exec(struct trace_event_raw_sched_process_exec *ctx)
{
    ...
    fname_off = ctx-&gt;__data_loc_filename &amp; 0xFFFF
    bpf_probe_read_str(&amp;e-&gt;filename, sizeof(e-&gt;filename), (void *)ctx + fname_off);
}
</code></pre>
</li>
<li>
<p>唯讀的全域變數定義須包含 const volatile ，跟 MMIO 操作的道理相同</p>
<pre><code class="language-c">const volatile unsigned long long min_duration_ns = 0;
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="實作-編譯bootstrap"><a class="header" href="#實作-編譯bootstrap">實作: 編譯bootstrap</a></h1>
<ul>
<li>撰寫 makefile ，使用命令 <code>make &lt;target&gt;</code> 編譯 boostrap 執行檔</li>
<li>觀察 boostrap 程式的輸出，確認程式正常運作</li>
<li>閱讀 boostrap 程式碼以下功能的實作，因為下一次會需要實作同樣功能：
<ul>
<li>使用 hash map 紀錄時間</li>
<li>用戶和核心使用 ring buffer 傳遞資料</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="撰寫追蹤程式-以tcprtt為例"><a class="header" href="#撰寫追蹤程式-以tcprtt為例">撰寫追蹤程式: 以tcprtt為例</a></h1>
<p>開發 fentry、tracepoint 兩種追蹤程式，輸出 TCP/IPV4 的延遲時間（round trip time）。範例輸出如下</p>
<pre><code class="language-shell">$ sudo ./tcprtt_tp 
PID     COMM             SRC                         DST                     LAT(ms)
0       swapper/0        192.168.68.64   :53393  --&gt; 20.42.65.94     :47873  196934.87
0       swapper/0        192.168.68.64   :52931  --&gt; 172.217.163.36  :20480  6854.23
</code></pre>
<p>fentry 使用 ring buffer ， tracepoint 使用 ring buffer 和 hash map，可以參考 bootstrap 使用 map 的流程</p>
<h2 id="fentrytracepoint-實作共通說明"><a class="header" href="#fentrytracepoint-實作共通說明">fentry、tracepoint 實作共通說明</a></h2>
<ul>
<li>
<p>流程：</p>
<ul>
<li>核心程式：搜集網路通訊資料，使用 ring buffer 傳遞到用戶</li>
<li>用戶程式：加載和附著核心程式，迴圈不斷接收 ring buffer 資料輸出到終端</li>
</ul>
</li>
<li>
<p>提供的檔案介紹：</p>
<ul>
<li><strong>tcprtt.c</strong>：fentry 用戶的完整程式</li>
<li><strong>tcprtt_tp.c</strong>：tracepoint 用戶的完整程式</li>
<li><strong>tcprtt.bpf.c</strong>：待完成的 fentry 核心程式</li>
<li><strong>tcprtt_tp.bpf.c</strong>：待完成的 tracepoint 核心程式</li>
</ul>
</li>
</ul>
<h2 id="完成目標"><a class="header" href="#完成目標">完成目標</a></h2>
<ul>
<li>開發 eBPF 核心程式，在用戶輸出 TCP 相關資訊，包含 pid, command, 目標和來源的 ip 及 port 和延遲時間
<ol>
<li>完成核心程式 <strong>tcprtt.bpf.c</strong>、<strong>tcprtt_tp.bpf.c</strong>。完成範例程式碼 TODO 部分</li>
<li>編譯執行檔 <strong>tcprtt</strong>、<strong>tcprtt_tp</strong></li>
<li>執行並確認 ip、port</li>
</ol>
</li>
<li>比較同一筆連線兩種方式得到的數值是否相符</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tracepoint-實作說明"><a class="header" href="#tracepoint-實作說明">tracepoint 實作說明</a></h1>
<p><img src="https://hackmd.io/_uploads/Sy-DmkxWyx.png" alt="tcp" /></p>
<p>三次交握時， socket 的狀態會改變。兩次“狀態改變”相隔的時間相當於 rtt ，也就是“從 <strong>SYN_SENT</strong> 到 <strong>ESTABLISHED</strong> 的時間”和“從 <strong>SYN_RECV</strong> 到 <strong>ESTABLISHED</strong> 的時間”，可以自行計算。</p>
<p><strong>inet_sock_set_state</strong> 這個 tracepoint 在每次 socket 狀態切換時被觸發，再透過 map 紀錄同個 socket 上次觸發的時間，就可以在狀態變成 <strong>ESTABLISHED</strong> 的時候計算 rtt 。另外，<strong>TCP_CLOSE</strong> 代表連線關閉，可以刪除 map 中的紀錄。</p>
<h2 id="tcprtt_tpbpfc-示範程式碼"><a class="header" href="#tcprtt_tpbpfc-示範程式碼">tcprtt_tp.bpf.c 示範程式碼</a></h2>
<pre><code class="language-c">#include "vmlinux.h"
#include &lt;bpf/bpf_helpers.h&gt;
#include &lt;bpf/bpf_tracing.h&gt;
#include &lt;bpf/bpf_core_read.h&gt;

#include "tcprtt.h"

#include "bpf_tracing_net.h"

// TODO: define ring buffer
// TODO: define hash map

SEC("tracepoint/sock/inet_sock_set_state")
int handle_set_state(struct trace_event_raw_inet_sock_set_state *ctx)
{
    // handle ipv4 only
    if (ctx-&gt;family != AF_INET)
        return 0;
    
    // TODO:
    // if oldstate, newstate are desired states:
    //     蒐集 ip, port，計算 rtt
    //     ring buffer 發送資料

    // if newstate == TCP_CLOSE:
    //     刪除 map 紀錄
    // else
    //     在 map 紀錄時間
    return 0;
}
</code></pre>
<h2 id="搜集資料"><a class="header" href="#搜集資料">搜集資料</a></h2>
<ul>
<li>ip 和 port：從 <code>struct trace_event_raw_inet_sock_set_state *ctx</code> 取得</li>
<li>rtt：<code>bpf_ktime_get_ns()</code> 可以取得當前時間，map 紀錄上次觸發的時間，兩者相減得到 rtt</li>
</ul>
<h3 id="參數類別說明"><a class="header" href="#參數類別說明">參數類別說明</a></h3>
<pre><code class="language-c">struct trace_event_raw_inet_sock_set_state {
    ...
    const void *skaddr;
    int oldstate;
    int newstate;
    __u16 sport;
    __u16 dport;
    __u8 saddr[4];
    __u8 daddr[4];
};
</code></pre>
<ul>
<li><code>skaddr</code>: 儲存 <code>struct sock</code> 的位址，可作為 hash map 的鍵</li>
<li><code>old_state</code>, <code>newstate</code>: socket 狀態，例如： <strong>TCP_ESTABLISHED</strong>, <strong>TCP_SYN_SENT</strong> ，定義在 vmlinux.h</li>
<li><code>saddr</code>, <code>daddr</code>: ip，網路位元組順序，用 <code>bpf_core_read(dst, sz, src)</code> 讀取</li>
<li><code>sport</code>, <code>dport</code>: port，本機位元組順序</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fentry-實作說明"><a class="header" href="#fentry-實作說明">fentry 實作說明</a></h1>
<p><code>void tcp_rcv_established(struct sock *sk, struct sk_buff *skb);</code></p>
<p>上面是附著的核心函式。當連線建立以後，每次用戶傳輸都會呼叫此函式。 fentry 的函式簽名會與附著的函式相同，並且可以讀取引數，例如 <code>sk</code>、<code>skb</code>，就可以藉此得到所需資訊。</p>
<h2 id="tcprttbpfc-示範程式碼"><a class="header" href="#tcprttbpfc-示範程式碼">tcprtt.bpf.c 示範程式碼</a></h2>
<pre><code class="language-c">#include "vmlinux.h"
#include &lt;bpf/bpf_helpers.h&gt;
#include &lt;bpf/bpf_tracing.h&gt;
#include &lt;bpf/bpf_core_read.h&gt;
#include &lt;bpf/bpf_endian.h&gt;

// for the definition of the type shared between user and kernel
#include "tcprtt.h"

#include "bpf_tracing_net.h"
    
// TODO: define ring buffer

SEC("fentry/tcp_rcv_established")
int BPF_PROG(tcp_rcv, struct sock *sk /*, optional */)
{
    // handler ipv4 only
    if (sk-&gt;__sk_common.skc_family != AF_INET)
        return 0;
    
    // TODO:
    // 蒐集 ip, port...
    // ring buffer 發送蒐集的資料
    return 0;
}
</code></pre>
<p>使用 <code>BPF_PROG()</code> 定義 fentry 函式， <code>tcp_rcv</code> 是實際函式的名稱，後面則是參數，要依序對應附著的核心函式的參數。</p>
<h2 id="蒐集資料"><a class="header" href="#蒐集資料">蒐集資料</a></h2>
<ul>
<li>pid, command：使用 <code>bpf_get_current_pid_tgid()</code>、<code>bpf_get_current_comm()</code>，用法參考 minimal 和 bootstrap</li>
<li>ip, port 和 rtt：需要從 <code>struct sock *sk</code> 取得</li>
</ul>
<h3 id="ip-和-port"><a class="header" href="#ip-和-port">ip 和 port</a></h3>
<p>被封裝在 <code>__sk_common</code>  中</p>
<pre><code class="language-c">struct sock {
    struct sock_common    __sk_common;
    ...
};
</code></pre>
<p>類別其實都是整數，然後 <code>skc_rcv_saddr</code> 是來源 ip ，<code>skc_num</code> 是來源 port 。 只有 <code>skc_num</code> 是以 host endian ，其他皆為 network endian</p>
<pre><code class="language-c">/**
 *	struct sock_common - minimal network layer representation of sockets
 *	@skc_daddr: Foreign IPv4 addr
 *	@skc_rcv_saddr: Bound local IPv4 addr
 *	@skc_dport: placeholder for inet_dport/tw_dport
 *	@skc_num: placeholder for inet_num/tw_num
 *	@skc_family: network address family
 *  ...
 */
 
struct sock_common {
    __be32	skc_daddr;
    __be32	skc_rcv_saddr;
    ...
}
</code></pre>
<p>核心程式用 host endian 紀錄 port ，network endian 紀錄 ip，可以利用 <code>bpf_ntohs()</code></p>
<h3 id="rtt"><a class="header" href="#rtt">rtt</a></h3>
<p>使用 bpf_tracing_net.h 中的 <code>tcp_sk()</code>，傳入 <code>sk</code> 呼叫得到 <code>struct tcp_sock *</code> 。</p>
<pre><code class="language-c">struct tcp_sock {
    u32	srtt_us;	/* smoothed round trip time &lt;&lt; 3 in usecs */`
    ...
};
</code></pre>
<p>將 <code>srtt_us</code> 右移三位元就是 rtt 。因為 <code>struct tcp_sock</code> 是核心記憶體，得用 <code>BPF_CORE_READ</code> 讀取。</p>
<h2 id="測試範例"><a class="header" href="#測試範例">測試範例</a></h2>
<p>在本機可以透過命令列工具簡單製造 tcp 連線</p>
<pre><code class="language-shell"># server
$ python3 -m http.server

# client
$ curl 0.0.0.0:8000
</code></pre>
<p>比對輸出紀錄的 ip、port ，確認運作正常</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="參考資料"><a class="header" href="#參考資料">參考資料</a></h1>
<ul>
<li><a href="https://nakryiko.com/posts/libbpf-bootstrap">build eBPF with libbpf-bootstrap</a></li>
<li>"Learning eBPF"--Liz Rice</li>
<li><a href="https://qmonnet.github.io/whirl-offload/2021/09/23/bpftool-features-thread/">meet bpftool</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
